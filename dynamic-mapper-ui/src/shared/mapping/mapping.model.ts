/*
 * Copyright (c) 2025 Cumulocity GmbH
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @authors Christof Strack
 */

import { ProcessingContext, TOKEN_IDENTITY } from './../../mapping/core/processor/processor.model';
import { EditorMode } from '../../mapping/shared/stepper.model';
import { ConnectorConfiguration } from '../connector-configuration/connector.model';

/**
 * Field substitution configuration for transforming data between source and target formats during mapping execution.
 * Defines how to extract data from source payloads using JSONPath and where to place it in target payloads.
 */
export interface Substitution {
  [x: string]: any;

  /**
   * JSONPath expression to extract data from the source payload.
   * Supports standard JSONPath syntax including:
   * - Root reference: $
   * - Property access: $.temperature, $.device.id
   * - Array access: $.readings[0], $.sensors[*].value
   * - Wildcards: $.devices.*.name
   * - Filters: $.readings[?(@.type == 'temperature')]
   * 
   * @example "$.device.temperature"
   */
  pathSource: string;

  /**
   * JSONPath expression defining where to place the extracted data in the target payload.
   * Can reference:
   * - Static paths: $.temperature.value
   * - Device identity: _IDENTITY_.c8ySourceId, _IDENTITY_.externalId
   * - Topic levels: _TOPIC_LEVEL_[0], _TOPIC_LEVEL_[1]
   * - Context data: _CONTEXT_DATA_.timestamp
   * 
   * @example "$.c8y_TemperatureMeasurement.T.value"
   */
  pathTarget: string;

  /** Strategy to handle data extraction and transformation edge cases */
  repairStrategy: RepairStrategy;

  /** 
   * Whether to expand arrays by creating multiple target objects (one for each array element) 
   * instead of copying the entire array 
   */
  expandArray: boolean;
}

export interface DeploymentMapEntry {
  identifier: string;
  connectors: string[];
  connectorsDetailed?: ConnectorConfiguration[];
}

export interface DeploymentMap {
  [x: string]: DeploymentMapEntry;
}

/**
 * Mapping configuration for transforming data between external systems and Cumulocity IoT.
 * Defines how incoming data from external sources should be transformed and routed
 * to appropriate Cumulocity IoT APIs, or how outbound data should be sent to external systems.
 */
export interface Mapping {
  [x: string]: any;

  /** Unique identifier for the mapping generated by Cumulocity Core */
  id: string;

  /** Generated identifier for the mapping */
  identifier: string;

  /** Display name for the mapping */
  name: string;

  /** Topic where outbound messages will be published */
  publishTopic?: string;

  /** Sample topic for outbound publishing */
  publishTopicSample?: string;

  /** Topic pattern for incoming messages (supports MQTT wildcards) */
  mappingTopic?: string;

  /** Sample topic for incoming messages */
  mappingTopicSample?: string;

  /** Target API for the mapping (e.g., 'MEASUREMENT', 'EVENT', 'ALARM', 'INVENTORY') */
  targetAPI: string;

  /** Direction of data flow */
  direction: Direction;

  /** 
   * JSON template for source data structure.
   * Example: {"temperature": 25.5, "deviceId": "sensor001"}
   */
  sourceTemplate: string;

  /** 
   * JSON template for target data structure.
   * Example: {"source": {"id": "sensor001"}, "type": "c8y_TemperatureMeasurement"}
   */
  targetTemplate: string;

  /** Type of mapping payload */
  mappingType: MappingType;

  /** Type of transformation */
  transformationType: TransformationType;

  /** Array of field substitutions for data transformation */
  substitutions?: Substitution[];

  /** Filter expression (condition) if mapping should be applied  (e.g., "telemetry.telemetryReadings[0].value >15") */
  filterMapping?: string;

  /** Filter expression for inventory queries (e.g., "has(c8y_IsDevice)") */
  filterInventory?: string;

  /** Maximum number of failures before disabling mapping */
  maxFailureCount?: number;

  /** Whether the mapping is currently active */
  active: boolean;

  /** Whether debug mode is enabled for this mapping */
  debug: boolean;

  /** Whether the mapping has been tested */
  tested: boolean;

  /** Whether the mapping supports message context */
  supportsMessageContext?: boolean;

  /** Whether events can have attachments */
  eventWithAttachment?: boolean;

  /** Whether to create devices that don't exist */
  createNonExistingDevice: boolean;

  /** Whether to update existing devices */
  updateExistingDevice: boolean;

  /** Whether to automatically acknowledge operations */
  autoAckOperation?: boolean;

  /** Whether to use external ID for device identification */
  useExternalId: boolean;

  /** Type of external ID to use (e.g., "c8y_Serial") */
  externalIdType: string;

  /** Status of template snooping */
  snoopStatus: SnoopStatus;

  /** List of templates captured during snooping */
  snoopedTemplates?: string[];

  /** Extension configuration for custom processing */
  extension?: ExtensionEntry;

  /** Quality of Service level for MQTT */
  qos: Qos;

  /** Base64 encoded code for custom substitutions */
  code?: string;

  /** Timestamp of last update */
  lastUpdate: number;
}

export interface MappingEnriched {
  id: string;
  mapping: Mapping;
  connectors?: ConnectorConfiguration[];
  snoopSupported?: boolean;
}

export interface DeploymentMapEntryDetailed {
  identifier: string;
  connectors?: ConnectorConfiguration[];
}

/**
 * Strategies for handling edge cases during field substitution and data transformation.
 * These strategies define how the mapping engine should behave when encountering
 * missing data, arrays, or other special conditions during data transformation.
 */
export enum RepairStrategy {
  /** Process substitution as defined without any special handling */
  DEFAULT = 'DEFAULT',

  /** If extracted content from source is an array, use only the first element */
  USE_FIRST_VALUE_OF_ARRAY = 'USE_FIRST_VALUE_OF_ARRAY',

  /** If extracted content from source is an array, use only the last element */
  USE_LAST_VALUE_OF_ARRAY = 'USE_LAST_VALUE_OF_ARRAY',

  /** Skip this substitution if source path evaluation fails */
  IGNORE = 'IGNORE',

  /** Remove the target node if source evaluation returns undefined, null, or empty. Enables dynamic content handling */
  REMOVE_IF_MISSING_OR_NULL = 'REMOVE_IF_MISSING_OR_NULL',

  /** Create the target node if it doesn't exist. Enables dynamic content creation */
  CREATE_IF_MISSING = 'CREATE_IF_MISSING'
}

export enum Direction {
  INBOUND = 'INBOUND',
  OUTBOUND = 'OUTBOUND'
}

export enum SnoopStatus {
  NONE = 'NONE',
  ENABLED = 'ENABLED',
  STARTED = 'STARTED',
  STOPPED = 'STOPPED'
}

export interface ExtensionEntry {
  extensionName: string;
  eventName: string;
  fqnClassName?: string;
  loaded?: boolean;
  message?: string;
  extensionType: ExtensionType
}

export enum ExtensionType {
  EXTENSION_SOURCE = 'EXTENSION_SOURCE',
  EXTENSION_SOURCE_TARGET = 'EXTENSION_SOURCE_TARGET',
}

export enum Qos {
  AT_MOST_ONCE = 'AT_MOST_ONCE',
  AT_LEAST_ONCE = 'AT_LEAST_ONCE',
  EXACTLY_ONCE = 'EXACTLY_ONCE'
}

export interface StepperConfiguration {
  showEditorSource?: boolean;
  showEditorTarget?: boolean;
  showProcessorExtensionsSource?: boolean;
  showProcessorExtensionsSourceTarget?: boolean;
  showProcessorExtensionsInternal?: boolean;
  showCodeEditor?: boolean;
  editorMode?: EditorMode;
  allowNoDefinedIdentifier?: boolean;
  allowDefiningSubstitutions?: boolean;
  allowTestTransformation?: boolean;
  allowTestSending?: boolean;
  direction?: Direction;
  advanceFromStepToEndStep?: number;
}

export enum TransformationType {
  DEFAULT = 'DEFAULT',
  SUBSTITUTION_AS_CODE = 'SUBSTITUTION_AS_CODE',
  SMART_FUNCTION = 'SMART_FUNCTION',
  JSONATA = 'JSONATA'
}

export enum MappingType {
  JSON = 'JSON',
  FLAT_FILE = 'FLAT_FILE',
  HEX = 'HEX',
  PROTOBUF_INTERNAL = 'PROTOBUF_INTERNAL',
  EXTENSION_SOURCE = 'EXTENSION_SOURCE',
  EXTENSION_SOURCE_TARGET = 'EXTENSION_SOURCE_TARGET',
  CODE_BASED = 'CODE_BASED'
}

export const TransformationTypeLabels = {
[Direction.INBOUND]:{  [TransformationType.DEFAULT]: 'Default Transformation',
  [TransformationType.SUBSTITUTION_AS_CODE]: 'Substitution as JavaScript Code',
  [TransformationType.SMART_FUNCTION]: 'Smart Function (JavaScript) to create Cumulocity API calls',
  [TransformationType.JSONATA]: 'Substitution as JSONata Expression'},
  [Direction.OUTBOUND]:{  [TransformationType.DEFAULT]: 'Default Transformation',
  [TransformationType.SUBSTITUTION_AS_CODE]: 'Substitution as JavaScript Code',
  [TransformationType.SMART_FUNCTION]: 'Smart Function (JavaScript) to create Broker Payload',
  [TransformationType.JSONATA]: 'Substitution as JSONata Expression'}
} as const;

export const TransformationTypeDescriptions = {
  [TransformationType.DEFAULT]: 'Uses the default transformation logic without custom processing',
  [TransformationType.SUBSTITUTION_AS_CODE]: 'Allows writing custom JavaScript code for complex transformations',
  [TransformationType.SMART_FUNCTION]: 'Executes a predefined Smart Function for data transformation and create payload for Cumulocity API calls',
  [TransformationType.JSONATA]: 'Uses JSONata query and transformation language for data mapping'
} as const;

export const MappingTypeLabels = {
  [MappingType.JSON]: 'JSON Payload',
  [MappingType.FLAT_FILE]: 'Flat File Payload',
  [MappingType.HEX]: 'Hexadecimal Payload',
  [MappingType.PROTOBUF_INTERNAL]: 'PROTOBUF Payload',
  [MappingType.EXTENSION_SOURCE]: 'Payload parsed in Java Extension',
  [MappingType.EXTENSION_SOURCE_TARGET]: 'Payload parsed and sent in Extension',
  [MappingType.CODE_BASED]: 'Code-based Mapping'
} as const;

export const MappingTypeDescriptions = {
  [MappingType.JSON]: 'Standard JSON payload transformation and mapping',
  [MappingType.FLAT_FILE]: 'Fixed-width or delimited flat file processing',
  [MappingType.HEX]: 'Hexadecimal data processing and conversion',
  [MappingType.PROTOBUF_INTERNAL]: 'Payload is in PROTOBUF format and is parsed by an internal extension',
  [MappingType.EXTENSION_SOURCE]: 'Custom extension for source data processing',
  [MappingType.EXTENSION_SOURCE_TARGET]: 'Custom extension for both source and target processing',
  [MappingType.CODE_BASED]: 'Fully customizable code-based transformation logic'
} as const;

export interface MappingTypeProperties {
  snoopSupported: boolean;
  directionSupported: boolean;
  substitutionsAsCodeSupported: boolean;
  supportedTransformationTypes: TransformationType[]; // Add this line
}

export interface MappingTypeDescriptionInterface {
  key: MappingType;
  description: string;
  enabled: boolean;
  properties: Record<Direction, MappingTypeProperties>;
  stepperConfiguration: StepperConfiguration;
}

export const MappingTypeDescriptionMap: Record<
  MappingType,
  MappingTypeDescriptionInterface
> = {
  [MappingType.JSON]: {
    key: MappingType.JSON,
    enabled: true,
    description: 'Mapping handles payloads in JSON format.',
    properties: {
      [Direction.INBOUND]: {
        snoopSupported: true,
        directionSupported: true,
        substitutionsAsCodeSupported: true,
        supportedTransformationTypes: [
          TransformationType.DEFAULT,
          TransformationType.JSONATA,
          TransformationType.SUBSTITUTION_AS_CODE,
          TransformationType.SMART_FUNCTION
        ]
      },
      [Direction.OUTBOUND]: {
        snoopSupported: true,
        directionSupported: true,
        substitutionsAsCodeSupported: true,
        supportedTransformationTypes: [
          TransformationType.DEFAULT,
          TransformationType.JSONATA,
          TransformationType.SUBSTITUTION_AS_CODE,
          TransformationType.SMART_FUNCTION
        ]
      },
    },
    stepperConfiguration: {
      showCodeEditor: false,
      showEditorSource: true,
      showEditorTarget: true,
      allowNoDefinedIdentifier: false,
      allowDefiningSubstitutions: true,
      showProcessorExtensionsSource: false,
      allowTestTransformation: true,
      allowTestSending: true
    }
  },
  [MappingType.FLAT_FILE]: {
    key: MappingType.FLAT_FILE,
    enabled: true,
    description: `Mapping handles payloads in CSV format. Any separator can be defined./nUse the following expression to return the fields in an array.\nFor the expression $split(payload, /,\\s*/) the result is:
      [
        "165",
        "14.5",
        "2022-08-06T00:14:50.000+02:00",
        "c8y_FuelMeasurement"
      ]
      .`,
    properties: {
      [Direction.INBOUND]: {
        snoopSupported: true,
        directionSupported: true,
        substitutionsAsCodeSupported: true,
        supportedTransformationTypes: [
          TransformationType.DEFAULT,
          TransformationType.JSONATA,
          TransformationType.SUBSTITUTION_AS_CODE,
          TransformationType.SMART_FUNCTION
        ]
      },
      [Direction.OUTBOUND]: {
        snoopSupported: false,
        directionSupported: false,
        substitutionsAsCodeSupported: false,
        supportedTransformationTypes: [
          TransformationType.DEFAULT,
          TransformationType.JSONATA,
          TransformationType.SUBSTITUTION_AS_CODE,
          TransformationType.SMART_FUNCTION
        ]
      },
    },
    stepperConfiguration: {
      showCodeEditor: false,
      showEditorSource: true,
      showEditorTarget: true,
      allowNoDefinedIdentifier: false,
      allowDefiningSubstitutions: true,
      showProcessorExtensionsSource: false,
      allowTestTransformation: true,
      allowTestSending: true
    }
  },
  [MappingType.HEX]: {
    key: MappingType.HEX,
    enabled: true,
    description: `Mapping handles payloads in hex format. In the mapper the incoming hexadecimal payload is decoded as hexadecimal string with a leading "0x". 
Use the JSONata function "$number() to parse an hexadecimal string as a number, e.g. $number("0x5a75") returns 23157.`,
    properties: {
      [Direction.INBOUND]: {
        snoopSupported: true,
        directionSupported: true,
        substitutionsAsCodeSupported: true,
        supportedTransformationTypes: [
          TransformationType.DEFAULT,
          TransformationType.JSONATA,
          TransformationType.SUBSTITUTION_AS_CODE,
          TransformationType.SMART_FUNCTION
        ]
      },
      [Direction.OUTBOUND]: {
        snoopSupported: false,
        directionSupported: false,
        substitutionsAsCodeSupported: false,
        supportedTransformationTypes: [
          TransformationType.DEFAULT,
          TransformationType.JSONATA,
          TransformationType.SUBSTITUTION_AS_CODE,
          TransformationType.SMART_FUNCTION
        ]
      }
    },
    stepperConfiguration: {
      showCodeEditor: false,
      showEditorSource: true,
      showEditorTarget: true,
      allowNoDefinedIdentifier: false,
      allowDefiningSubstitutions: true,
      showProcessorExtensionsSource: false,
      allowTestTransformation: true,
      allowTestSending: true
    }
  },
  [MappingType.PROTOBUF_INTERNAL]: {
    key: MappingType.PROTOBUF_INTERNAL,
    enabled: true,
    description: 'Mapping parses payloads in PROTOBUF format by an internal extension.',
    properties: {
      [Direction.INBOUND]: {
        snoopSupported: false,
        directionSupported: true,
        substitutionsAsCodeSupported: false,
        supportedTransformationTypes: [TransformationType.DEFAULT]
      },
      [Direction.OUTBOUND]: {
        snoopSupported: false,
        directionSupported: false,
        substitutionsAsCodeSupported: false,
        supportedTransformationTypes: [] // No transformation types supported for outbound
      },
    },
    stepperConfiguration: {
      showProcessorExtensionsSource: false,
      showProcessorExtensionsInternal: true,
      allowDefiningSubstitutions: false,
      showCodeEditor: false,
      showEditorSource: false,
      showEditorTarget: true,
      allowNoDefinedIdentifier: true,
      allowTestTransformation: false,
      allowTestSending: false
    }
  },
  [MappingType.EXTENSION_SOURCE]: {
    key: MappingType.EXTENSION_SOURCE,
    enabled: true,
    description:
      'Mapping handles payloads in custom format. It can be used if you want to process the message yourself. This requires that a custom processor extension in Java is implemented and uploaded through the "Processor extension" tab.',
    properties: {
      [Direction.INBOUND]: {
        snoopSupported: false,
        directionSupported: true,
        substitutionsAsCodeSupported: false,
        supportedTransformationTypes: [TransformationType.DEFAULT]
      },
      [Direction.OUTBOUND]: {
        snoopSupported: false,
        directionSupported: false,
        substitutionsAsCodeSupported: false,
        supportedTransformationTypes: [] // No transformation types supported for outbound
      },
    },
    stepperConfiguration: {
      showProcessorExtensionsSource: true,
      showProcessorExtensionsSourceTarget: false,
      allowDefiningSubstitutions: false,
      showCodeEditor: false,
      showEditorSource: false,
      showEditorTarget: true,
      allowNoDefinedIdentifier: true,
      allowTestTransformation: false,
      allowTestSending: false,
      advanceFromStepToEndStep: 2
    }
  },
  [MappingType.EXTENSION_SOURCE_TARGET]: {
    key: MappingType.EXTENSION_SOURCE_TARGET,
    enabled: false,
    description:
      'Mapping handles payloads in custom format. In contrast to the EXTENSION_SOURCE the completed processing of the payload: extract values from the incoming payload and then transform this to a Cumulocity API call. This requires that a custom processor extension in Java is implemented and uploaded through the "Processor extension" tab.',
    properties: {
      [Direction.INBOUND]: {
        snoopSupported: false,
        directionSupported: true,
        substitutionsAsCodeSupported: false,
        supportedTransformationTypes: [] // No transformation types supported
      },
      [Direction.OUTBOUND]: {
        snoopSupported: false,
        directionSupported: false,
        substitutionsAsCodeSupported: false,
        supportedTransformationTypes: [] // No transformation types supported
      },
    },
    stepperConfiguration: {
      showProcessorExtensionsSource: false,
      showProcessorExtensionsSourceTarget: true,
      allowDefiningSubstitutions: false,
      showEditorSource: false,
      showEditorTarget: false,
      allowNoDefinedIdentifier: true,
      allowTestTransformation: false,
      allowTestSending: false,
      advanceFromStepToEndStep: 2
    }
  },
  [MappingType.CODE_BASED]: {
    key: MappingType.CODE_BASED,
    enabled: false,
    description: 'Mapping handles payloads in JSON format and defines substitutions as code.',
    properties: {
      [Direction.INBOUND]: {
        snoopSupported: true,
        directionSupported: false,
        substitutionsAsCodeSupported: false,
        supportedTransformationTypes: [] // No transformation types supported
      },
      [Direction.OUTBOUND]: {
        snoopSupported: true,
        directionSupported: true,
        substitutionsAsCodeSupported: false,
        supportedTransformationTypes: [] // No transformation types supported
      },
    },
    stepperConfiguration: {
      showEditorSource: true,
      showEditorTarget: true,
      showCodeEditor: true,
      allowNoDefinedIdentifier: false,
      allowDefiningSubstitutions: true,
      showProcessorExtensionsSource: false,
      allowTestTransformation: true,
      allowTestSending: false
    }
  }
};

export interface Extension {
  id?: string;
  name: string;
  extensionEntries: Map<string, ExtensionEntry>;
  loaded: boolean;
  external: boolean;
}

export enum ExtensionStatus {
  COMPLETE = 'COMPLETE',
  PARTIALLY = 'PARTIALLY',
  NOT_LOADED = 'NOT_LOADED',
  UNKNOWN = 'UNKNOWN'
}

export interface MappingStatus {
  id: number;
  name: string;
  identifier: string;
  direction: Direction;
  mappingTopic: string;
  errors: number;
  messagesReceived: number;
  snoopedTemplatesTotal: number;
  snoopedTemplatesActive: number;
}

export const API = {
  ALARM: {
    name: 'ALARM',
    identifier: 'source.id',
    notificationFilter: 'alarms'
  },
  EVENT: {
    name: 'EVENT',
    identifier: 'source.id',
    notificationFilter: 'events'
  },
  MEASUREMENT: {
    name: 'MEASUREMENT',
    identifier: 'source.id',
    notificationFilter: 'measurements'
  },
  INVENTORY: {
    name: 'INVENTORY',
    identifier: 'id',
    notificationFilter: 'managedObjects'
  },
  OPERATION: {
    name: 'OPERATION',
    identifier: 'deviceId',
    notificationFilter: 'operations'
  },
  ALL: { name: 'ALL', identifier: '*', notificationFilter: '*' }
};
export interface Feature {
  outputMappingEnabled: boolean;
  externalExtensionsEnabled: boolean;
  userHasMappingCreateRole: boolean;
  userHasMappingAdminRole: boolean;
}export function getDeviceIdentifiers(mapping: Mapping): Substitution[] {
  const mp: Substitution[] = mapping.substitutions
    .filter(sub => definesDeviceIdentifier(mapping, sub));
  return mp;
}

export function getPathTargetForDeviceIdentifiers(context: ProcessingContext): string[] {
  const { mapping } = context;
  let pss;
  if (isSubstitutionsAsCode(mapping)) {
    pss = [getGenericDeviceIdentifier(mapping)];
  } else {
    pss = mapping.substitutions
      .filter(sub => definesDeviceIdentifier(mapping, sub))
      .map(sub => sub.pathTarget);
  }
  return pss;
}

export function transformGenericPath2C8YPath(mapping: Mapping, originalPath: string): string {
  // "_IDENTITY_.externalId" => source.id
  if (getGenericDeviceIdentifier(mapping) === originalPath) {
    return API[mapping.targetAPI].identifier;
  } else {
    return originalPath;
  }
}

export function transformC8YPath2GenericPath(mapping: Mapping, originalPath: string): string {
  // source.id => "_IDENTITY_.externalId" source.id
  if (API[mapping.targetAPI].identifier === originalPath) {
    return getGenericDeviceIdentifier(mapping);
  } else {
    return originalPath;
  }
}
export function cloneSubstitution(
  sub: Substitution
): Substitution {
  return {
    pathSource: sub.pathSource,
    pathTarget: sub.pathTarget,
    repairStrategy: sub.repairStrategy,
    expandArray: sub.expandArray,
  };
}
export function definesDeviceIdentifier(
  mapping: Mapping,
  sub: Substitution
): boolean {
  if (mapping.direction == Direction.INBOUND) {
    if (mapping.useExternalId) {
      return sub?.pathTarget == `${TOKEN_IDENTITY}.externalId`;
    } else {
      return sub?.pathTarget == `${TOKEN_IDENTITY}.c8ySourceId`;
    }
  } else {
    if (mapping.useExternalId) {
      return sub?.pathSource == `${TOKEN_IDENTITY}.externalId`;
    } else {
      return sub?.pathSource == `${TOKEN_IDENTITY}.c8ySourceId`;
    }
  }
}
export function isSubstitutionValid(mapping: Mapping): boolean {
  const count = mapping.substitutions
    .filter((sub) => definesDeviceIdentifier(mapping, sub)
    )
    .map(() => 1)
    .reduce((previousValue: number, currentValue: number) => {
      return previousValue + currentValue;
    }, 0);
  return (
    (mapping.direction != Direction.OUTBOUND && count == 1) ||
    mapping.direction == Direction.OUTBOUND
  );
}

export function countDeviceIdentifiers(mapping: Mapping): number {
  const n = mapping.substitutions.filter((sub) => definesDeviceIdentifier(mapping, sub)
  ).length;
  return n;
}
export function getGenericDeviceIdentifier(mapping: Mapping): string {
  if (mapping.useExternalId && mapping.externalIdType !== '') {
    return `${TOKEN_IDENTITY}.externalId`;
  } else {
    return `${TOKEN_IDENTITY}.c8ySourceId`;
  }
}

export function isSubstitutionsAsCode(mapping: Mapping): boolean {
  return  MappingType.CODE_BASED === mapping.mappingType || mapping.transformationType == TransformationType.SUBSTITUTION_AS_CODE || mapping.transformationType == TransformationType.SMART_FUNCTION;
}
