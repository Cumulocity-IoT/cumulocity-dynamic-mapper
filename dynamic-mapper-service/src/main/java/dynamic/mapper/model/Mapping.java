/*
 * Copyright (c) 2022-2025 Cumulocity GmbH.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  @authors Christof Strack, Stefan Witschel
 *
 */

package dynamic.mapper.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import dynamic.mapper.processor.model.MappingType;
import dynamic.mapper.processor.model.ProcessingType;
import dynamic.mapper.processor.model.TransformationType;
import jakarta.validation.constraints.NotNull;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;

import io.swagger.v3.oas.annotations.media.Schema;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonDeserialize(builder = Mapping.MappingBuilder.class)
@ToString(exclude = { "sourceTemplate", "targetTemplate", "snoopedTemplates", "code" })
@Schema(description = "Mapping configuration for transforming data between external systems and Cumulocity IoT")
public class Mapping implements Serializable {

    public static final String TOKEN_IDENTITY = "_IDENTITY_";
    public static final String TOKEN_TOPIC_LEVEL = "_TOPIC_LEVEL_";
    public static final String TOKEN_CONTEXT_DATA = "_CONTEXT_DATA_";
    public static final String CONTEXT_DATA_KEY_NAME = "key";
    public static final String CONTEXT_DATA_METHOD_NAME = "method";
    public static final String KEY_TIME = "time";

    public static int SNOOP_TEMPLATES_MAX = 10;
    public static final String SPLIT_TOPIC_REGEXP = "((?<=/)|(?=/))";
    public static Mapping UNSPECIFIED_MAPPING;

    static final String REGEXP_REMOVE_TRAILING_SLASHES = "#\\/$";
    static final String REGEXP_REDUCE_LEADING_TRAILING_SLASHES = "(\\/{2,}$)|(^\\/{2,})";
    static String TOPIC_WILDCARD_MULTI = "#";
    static String TOPIC_WILDCARD_SINGLE = "+";

    static {
        UNSPECIFIED_MAPPING = Mapping.builder().id(MappingStatus.IDENT_UNSPECIFIED_MAPPING)
                .identifier(MappingStatus.IDENT_UNSPECIFIED_MAPPING)
                .build();
    }

    @JsonPOJOBuilder(withPrefix = "", buildMethodName = "build")
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class MappingBuilder {
        // Lombok will generate all the builder methods
    }

    @Builder.Default
    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Unique identifier for the mapping generated by Cumulocity Core", example = "34573838974")
    @NotNull
    private String id = "id";

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Generated identifier for the mapping", example = "l19zjk")
    @NotNull
    private String identifier;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Display name for the mapping", example = "Temperature Sensor Data Mapping")
    @NotNull
    private String name;

    @Schema(description = "Topic where outbound messages will be published", example = "device/+/temperature")
    private String publishTopic;

    @Schema(description = "Sample topic for outbound publishing", example = "device/sensor001/temperature")
    private String publishTopicSample;

    @Schema(description = "Topic pattern for incoming messages (supports MQTT wildcards)", example = "sensors/+/data")
    private String mappingTopic;

    @Schema(description = "Sample topic for incoming messages", example = "sensors/temp001/data")
    private String mappingTopicSample;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Target API for the mapping", implementation = API.class)
    @NotNull
    private API targetAPI;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Direction of data flow", implementation = Direction.class, example = "INBOUND")
    @NotNull
    @JsonSetter(nulls = Nulls.SKIP)
    private Direction direction;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "JSON template for source data structure", example = "{\"temperature\": 25.5, \"deviceId\": \"sensor001\"}")
    @NotNull
    private String sourceTemplate;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "JSON template for target data structure", example = "{\"source\": {\"id\": \"sensor001\"}, \"type\": \"c8y_TemperatureMeasurement\"}")
    @NotNull
    private String targetTemplate;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Type of mapping payload", implementation = MappingType.class, example = "JSON")
    @JsonSetter(nulls = Nulls.SKIP)
    private MappingType mappingType;

    @Builder.Default
    @Schema(description = "Type of processing the transformation", implementation = ProcessingType.class, example = "SUBSTITUTION_AS_CODE")
    @NotNull
    private TransformationType transformationType = TransformationType.DEFAULT;

    @Builder.Default
    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Array of field substitutions for data transformation")
    @NotNull
    private Substitution[] substitutions = new Substitution[0];

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Whether the mapping is currently active", example = "true")
    @NotNull
    private Boolean active;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Whether debug mode is enabled for this mapping", example = "false")
    @NotNull
    private Boolean debug;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Whether the mapping has been tested", example = "true")
    @NotNull
    private Boolean tested;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Whether the mapping supports message context", example = "false")
    @NotNull
    private Boolean supportsMessageContext;

    @Builder.Default
    @Schema(description = "Whether events can have attachments", example = "false")
    @JsonSetter(nulls = Nulls.SKIP)
    private Boolean eventWithAttachment = false;

    @Builder.Default
    @Schema(description = "Whether to create devices that don't exist", example = "true")
    @JsonSetter(nulls = Nulls.SKIP)
    private Boolean createNonExistingDevice = false;

    @Builder.Default
    @Schema(description = "Whether to update existing devices", example = "true")
    @JsonSetter(nulls = Nulls.SKIP)
    private Boolean updateExistingDevice = false;

    @Builder.Default
    @Schema(description = "Whether to automatically acknowledge operations", example = "false")
    @JsonSetter(nulls = Nulls.SKIP)
    private Boolean autoAckOperation = false;

    @Builder.Default
    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Whether to use external ID for device identification", example = "true")
    @NotNull
    private Boolean useExternalId = false;

    @Schema(description = "Type of external ID to use", example = "c8y_Serial")
    private String externalIdType;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Status of template snooping", implementation = SnoopStatus.class, example = "ENABLED")
    @NotNull
    private SnoopStatus snoopStatus;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "List of templates captured during snooping")
    @NotNull
    private ArrayList<String> snoopedTemplates;

    @Schema(description = "Extension configuration for custom processing")
    @JsonSetter(nulls = Nulls.SKIP)
    private ExtensionEntry extension;

    @Schema(description = "Filter expression (condition) if mapping should be applied", example = "telemetry.telemetryReadings[0].value >15")
    @JsonSetter(nulls = Nulls.SKIP)
    private String filterMapping;

    @Schema(description = "Filter expression for inventory queries", example = "has(c8y_IsDevice)")
    @JsonSetter(nulls = Nulls.SKIP)
    private String filterInventory;

    @Builder.Default
    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Maximum number of failures before disabling mapping", example = "10")
    @NotNull
    private long maxFailureCount = 0;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Quality of Service level for MQTT", implementation = Qos.class, example = "AT_LEAST_ONCE")
    @NotNull
    private Qos qos;

    @Schema(description = "Base64 encoded code for custom substitutions")
    private String code;

    // @Schema(description = "Define substitutions as JavaScript code")
    // public Boolean substitutionsAsCode = false;

    @JsonSetter("substitutionsAsCode")
    @Deprecated
    public void setSubstitutionsAsCode(Boolean substitutionsAsCode) {
        // Migration logic when old property is used
        if (substitutionsAsCode != null && substitutionsAsCode) {
            // Default to SUBSTITUTION_AS_CODE when true
            // You might want to make this configurable or use different logic
            this.transformationType = TransformationType.SUBSTITUTION_AS_CODE;
        }
        // Set to null as per requirement
        this.substitutionsAsCode = null;
    }

    @Builder.Default
    @Schema(description = "Define substitutions as JavaScript code")
    @Deprecated(since = "version-6.0", forRemoval = true)
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY) // Only accept on input, don't serialize on output
    private Boolean substitutionsAsCode = false;

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Timestamp of last update", example = "1640995200000")
    @NotNull
    private long lastUpdate;

    public static final String EXTRACT_FROM_SOURCE = "extractFromSource";
    public static final String SMART_FUNCTION_NAME = "onMessage";

    @Override
    public boolean equals(Object m) {
        return (m instanceof Mapping) && id == ((Mapping) m).id;
    }

    @JsonIgnore
    public String getGenericDeviceIdentifier() {
        if (useExternalId && !("").equals(externalIdType)) {
            return (Mapping.TOKEN_IDENTITY + ".externalId");
        } else {
            return (Mapping.TOKEN_IDENTITY + ".c8ySourceId");
        }
    }

    @JsonIgnore
    public Boolean definesDeviceIdentifier(
            Substitution sub) {
        if (Direction.INBOUND.equals(direction)) {
            if (useExternalId && !("").equals(externalIdType)) {
                return (Mapping.TOKEN_IDENTITY + ".externalId").equals(sub.pathTarget);
            } else {
                return (Mapping.TOKEN_IDENTITY + ".c8ySourceId").equals(sub.pathTarget);
            }
        } else {
            if (useExternalId && !("").equals(externalIdType)) {
                return (Mapping.TOKEN_IDENTITY + ".externalId").equals(sub.pathSource);
            } else {
                return (Mapping.TOKEN_IDENTITY + ".c8ySourceId").equals(sub.pathSource);
            }
        }
    }

    @JsonIgnore
    public void addSnoopedTemplate(String payloadMessage) {
        snoopedTemplates.add(payloadMessage);
        if (snoopedTemplates.size() > SNOOP_TEMPLATES_MAX) {
            // remove oldest payload
            snoopedTemplates.remove(0);
        } else {
            snoopStatus = SnoopStatus.STARTED;
        }
    }

    @JsonIgnore
    public void sortSubstitutions() {
        Substitution[] sortedSubstitutions = Arrays.stream(substitutions).sorted(
                (s1, s2) -> -(Boolean.valueOf(definesDeviceIdentifier(s1))
                        .compareTo(
                                Boolean.valueOf(definesDeviceIdentifier(s2)))))
                .toArray(size -> new Substitution[size]);
        substitutions = sortedSubstitutions;
    }

    /*
     * "_IDENTITY_.externalId" => source.id
     */
    @JsonIgnore
    public String transformGenericPath2C8YPath(String originalPath) {
        // "_IDENTITY_.externalId" => source.id
        if (getGenericDeviceIdentifier().equals(originalPath)) {
            return targetAPI.identifier;
        } else {
            return originalPath;
        }
    }

    /*
     * source.id => "_IDENTITY_.externalId"
     */
    @JsonIgnore
    public String transformC8YPath2GenericPath(String originalPath) {
        if (targetAPI.identifier.equals(originalPath)) {
            return getGenericDeviceIdentifier();
        } else {
            return originalPath;
        }
    }

    @JsonIgnore
    public List<String> getPathTargetForDeviceIdentifiers() {
        List<String> pss = Arrays.stream(substitutions)
                .filter(sub -> definesDeviceIdentifier(sub))
                .map(sub -> sub.pathTarget)
                .toList();
        return pss;
    }

    public static String[] splitTopicIncludingSeparatorAsArray(String topic) {
        topic = topic.trim();
        StringBuilder result = new StringBuilder();
        boolean wasSlash = false;

        for (char c : topic.toCharArray()) {
            if (c == '/') {
                if (!wasSlash) {
                    result.append(c);
                }
                wasSlash = true;
            } else {
                result.append(c);
                wasSlash = false;
            }
        }
        return result.toString().split(SPLIT_TOPIC_REGEXP);
    }

    public static List<String> splitTopicIncludingSeparatorAsList(String topic) {
        return new ArrayList<String>(
                Arrays.asList(Mapping.splitTopicIncludingSeparatorAsArray(topic)));
    }

    public static String[] splitTopicExcludingSeparatorAsArray(String topic, boolean cutOffLeadingSlash) {
        String topix = topic.trim();

        if (cutOffLeadingSlash) {
            // Original behavior: remove both leading and trailing slashes
            topix = topix.replaceAll("(\\/{1,}$)|(^\\/{1,})", "");
            return topix.split("\\/");
        } else {
            // New behavior: keep leading slash, remove only trailing slashes
            topix = topix.replaceAll("\\/{1,}$", "");
            if (topix.startsWith("//")) {
                topix = "/" + topix.replaceAll("^/+", "");
            }

            if (topix.startsWith("/")) {
                String[] parts = topix.substring(1).split("\\/");
                String[] result = new String[parts.length + 1];
                result[0] = "/";
                System.arraycopy(parts, 0, result, 1, parts.length);
                return result;
            }

            return topix.split("\\/");
        }
    }

    public static List<String> splitTopicExcludingSeparatorAsList(String topic, boolean cutOffLeadingSlash) {
        return new ArrayList<String>(
                Arrays.asList(Mapping.splitTopicExcludingSeparatorAsArray(topic, cutOffLeadingSlash)));
    }

    /*
     * only one substitution can be marked with definesIdentifier == true
     */
    static public ArrayList<ValidationError> isSubstitutionValid(Mapping mapping) {
        ArrayList<ValidationError> result = new ArrayList<ValidationError>();
        long count = Arrays.asList(mapping.substitutions).stream()
                .filter(sub -> mapping.definesDeviceIdentifier(sub))
                .count();

        if (mapping.snoopStatus != SnoopStatus.ENABLED && mapping.snoopStatus != SnoopStatus.STARTED
                && !mapping.getMappingType().equals(MappingType.EXTENSION_SOURCE)
                && !mapping.getMappingType().equals(MappingType.EXTENSION_SOURCE_TARGET)
                && !mapping.getMappingType().equals(MappingType.PROTOBUF_INTERNAL)
                && !mapping.getMappingType().equals(MappingType.CODE_BASED)
                && !TransformationType.SMART_FUNCTION.equals(mapping.transformationType)
                && !TransformationType.SUBSTITUTION_AS_CODE.equals(mapping.transformationType)
                && !mapping.direction.equals(Direction.OUTBOUND)) {
            if (count > 1) {
                result.add(ValidationError.Only_One_Substitution_Defining_Device_Identifier_Can_Be_Used);
            }
            if (count < 1) {
                result.add(ValidationError.One_Substitution_Defining_Device_Identifier_Must_Be_Used);
            }

        }
        return result;
    }

    static public ArrayList<ValidationError> isMappingTopicValid(String topic) {
        ArrayList<ValidationError> result = new ArrayList<ValidationError>();
        int count = topic.length() - topic.replace(TOPIC_WILDCARD_SINGLE, "").length();
        // disable this test: Why is it still needed?
        // if (count > 1) {
        // result.add(ValidationError.Only_One_Single_Level_Wildcard);
        // }

        count = topic.length() - topic.replace(TOPIC_WILDCARD_MULTI, "").length();
        if (count > 1) {
            result.add(ValidationError.Only_One_Multi_Level_Wildcard);
        }
        if (count >= 1 && topic.indexOf(TOPIC_WILDCARD_MULTI) != topic.length() - 1) {
            result.add(ValidationError.Multi_Level_Wildcard_Only_At_End);
        }
        return result;
    }

    static public Boolean isWildcardTopic(String topic) {
        var result = topic.contains(TOPIC_WILDCARD_MULTI) || topic.contains(TOPIC_WILDCARD_SINGLE);
        return result;
    }

    static public List<ValidationError> isFilterOutboundUnique(List<Mapping> mappings, Mapping mapping) {
        ArrayList<ValidationError> result = new ArrayList<ValidationError>();
        var filterMapping = mapping.filterMapping;
        mappings.forEach(m -> {
            if ((filterMapping.equals(m.filterMapping))
                    && (mapping.id != m.id)) {
                result.add(ValidationError.FilterOutbound_Must_Be_Unique);
            }
        });
        return result;
    }

    static public List<ValidationError> isMappingValid(List<Mapping> mappings, Mapping mapping) {
        ArrayList<ValidationError> result = new ArrayList<ValidationError>();
        result.addAll(isSubstitutionValid(mapping));
        if (mapping.direction.equals(Direction.INBOUND)) {
            result.addAll(isMappingTopicValid(mapping.mappingTopic));
        } else {
            // test if we can attach multiple outbound mappings to the same filterMapping
            result.addAll(
                    Mapping.isPublishTopicTemplateAndPublishTopicSampleValid(mapping.publishTopic,
                            mapping.publishTopicSample));
        }

        result.addAll(areJSONTemplatesValid(mapping));
        // result.addAll(isMappingTopicUnique(mappings, mapping));
        return result;
    }

    static Collection<? extends ValidationError> isPublishTopicTemplateAndPublishTopicSampleValid(
            @NotNull String publishTopic, @NotNull String publishTopicSample) {
        ArrayList<ValidationError> result = new ArrayList<ValidationError>();
        String[] splitPT = splitTopicIncludingSeparatorAsArray(publishTopic);
        String[] splitTTS = splitTopicIncludingSeparatorAsArray(publishTopicSample);
        if (splitPT.length != splitTTS.length) {
            result.add(
                    ValidationError.PublishTopic_And_PublishTopicSample_Do_Not_Have_Same_Number_Of_Levels_In_Topic_Name);
        } else {
            for (int i = 0; i < splitPT.length; i++) {
                if (("/").equals(splitPT[i]) && !("/").equals(splitTTS[i])) {
                    result.add(
                            ValidationError.PublishTopic_And_PublishTopicSample_Do_Not_Have_Same_Structure_In_Topic_Name);
                    break;
                }
                if (("/").equals(splitTTS[i]) && !("/").equals(splitPT[i])) {
                    result.add(
                            ValidationError.PublishTopic_And_PublishTopicSample_Do_Not_Have_Same_Structure_In_Topic_Name);
                    break;
                }
                if (!("/").equals(splitPT[i]) && !("+").equals(splitPT[i]) && !("#").equals(splitPT[i])) {
                    if (!splitPT[i].equals(splitTTS[i])) {
                        result.add(
                                ValidationError.PublishTopic_And_PublishTopicSample_Do_Not_Have_Same_Structure_In_Topic_Name);
                        break;
                    }
                }
            }
        }
        return result;
    }

    /*
     * test if mapping.mappingTopic and mapping.mappingTopicSample have the same
     * structure and same number of levels
     */
    public static List<ValidationError> isMappingTopicAndMappingTopicSampleValid(String mappingTopic,
            String mappingTopicSample) {
        ArrayList<ValidationError> result = new ArrayList<ValidationError>();
        String[] splitTT = Mapping.splitTopicIncludingSeparatorAsArray(mappingTopic);
        String[] splitTTS = Mapping.splitTopicIncludingSeparatorAsArray(mappingTopicSample);
        if (splitTT.length != splitTTS.length) {
            result.add(
                    ValidationError.MappingTopic_And_MappingTopicSample_Do_Not_Have_Same_Number_Of_Levels_In_Topic_Name);
        } else {
            for (int i = 0; i < splitTT.length; i++) {
                if (("/").equals(splitTT[i]) && !("/").equals(splitTTS[i])) {
                    result.add(
                            ValidationError.MappingTopic_And_MappingTopicSample_Do_Not_Have_Same_Structure_In_Topic_Name);
                    break;
                }
                if (("/").equals(splitTTS[i]) && !("/").equals(splitTT[i])) {
                    result.add(
                            ValidationError.MappingTopic_And_MappingTopicSample_Do_Not_Have_Same_Structure_In_Topic_Name);
                    break;
                }
                if (!("/").equals(splitTT[i]) && !("+").equals(splitTT[i])) {
                    if (!splitTT[i].equals(splitTTS[i])) {
                        result.add(
                                ValidationError.MappingTopic_And_MappingTopicSample_Do_Not_Have_Same_Structure_In_Topic_Name);
                        break;
                    }
                }
            }
        }
        return result;
    }

    static Collection<ValidationError> areJSONTemplatesValid(Mapping mapping) {
        ArrayList<ValidationError> result = new ArrayList<ValidationError>();
        try {
            new JSONTokener(mapping.sourceTemplate).nextValue();
        } catch (JSONException e) {
            result.add(ValidationError.Source_Template_Must_Be_Valid_JSON);
        }

        if (!mapping.getMappingType().equals(MappingType.EXTENSION_SOURCE)
                && !mapping.getMappingType().equals(MappingType.PROTOBUF_INTERNAL)) {
            try {
                new JSONObject(mapping.targetTemplate);
            } catch (JSONException e) {
                result.add(ValidationError.Target_Template_Must_Be_Valid_JSON);
            }
        }

        return result;
    }

    static public String normalizeTopic(String topic) {
        if (topic == null)
            topic = "";
        // reduce multiple leading or trailing "/" to just one "/"
        String nt = topic.trim().replaceAll(REGEXP_REDUCE_LEADING_TRAILING_SLASHES, "/");
        // do not use starting slashes, see as well
        // https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/
        nt = nt.replaceAll(REGEXP_REMOVE_TRAILING_SLASHES, "#");
        return nt;
    }

    static public List<Substitution> getDeviceIdentifiers(Mapping mapping) {
        List<Substitution> mp = Arrays.stream(mapping.substitutions)
                .filter(sub -> mapping.definesDeviceIdentifier(sub))
                .toList();
        return mp;
    }

    public Boolean isTransformationAsCode() {
        return MappingType.CODE_BASED.equals(this.mappingType) ||
                TransformationType.SUBSTITUTION_AS_CODE.equals(this.transformationType) ||
                TransformationType.SMART_FUNCTION.equals(this.transformationType);
    }
}